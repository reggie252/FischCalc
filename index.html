<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Fishing Simulator</title>
<style>
body { font-family: sans-serif; margin: 2rem; background: #f9fafb; color: #111; }
h1 { font-size: 1.8rem; margin-bottom: 1rem; }
select, input, button { padding: 0.5rem; margin: 0.2rem; }
table { border-collapse: collapse; width: 100%; margin-top: 1rem; }
th, td { border: 1px solid #ccc; padding: 0.5rem; text-align: left; }
th { background: #eee; }
.card { background: white; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
.uncatchable { color: red; font-weight: bold; }
</style>
</head>
<body>
<h1>ðŸŽ£ Fishing Simulator</h1>

<div class="card" id="simControls" style="display:none;">
  <label>Main Area:</label>
  <select id="mainAreaSelect" onchange="onMainAreaChange()"></select>

  <label>Sub-Location:</label>
  <select id="subLocationSelect"></select>

  <label>Rod:</label>
  <select id="rodSelect" onchange="updateStatsDisplay()"></select>

  <label>Enchantment:</label>
  <select id="enchantSelect" onchange="updateStatsDisplay()"></select>

  <label>Bait:</label>
  <select id="baitSelect" onchange="updateBaitStatsDisplay()"></select>
  <div id="baitStats" style="margin:0.5rem 0; font-weight:bold;">Bait Stats: -</div>

  <div id="rodStats" style="margin:0.5rem 0; font-weight:bold;">Rod Stats: -</div>

  <label>Hours:</label>
  <input type="number" id="hoursInput" value="1" step="0.5" min="0" />

  <label>Season:</label>
  <select id="seasonSelect">
    <option value="Spring">Spring</option>
    <option value="Summer">Summer</option>
    <option value="Autumn">Autumn</option>
    <option value="Winter" selected>Winter</option>
  </select>

  <label>Time:</label>
  <select id="timeSelect">
    <option value="Day" selected>Day</option>
    <option value="Night">Night</option>
  </select>

  <label>Weather:</label>
  <select id="weatherSelect">
    <option value="Clear" selected>Clear</option>
    <option value="Aurora Borealis">Aurora Borealis</option>
    <option value="Rain">Rain</option>
    <option value="Windy">Windy</option>
    <option value="Foggy">Foggy</option>
    <option value="Eclipse">Eclipse</option>
  </select>

  <button onclick="runSimulation()">Run Simulation</button>
</div>

<div class="card">
  <h2>Results</h2>
  <div id="results">No simulation yet.</div>
</div>

<script>
let Areas = {};
let FishStats = {};
let Rods = {};
let Enchantments = {};
let BaitData = {};
let SelectedEnchantStats = [0,0,0,0,0,0];

async function fetchJson(path) {
  const res = await fetch(path);
  if (!res.ok) throw new Error(`Failed to load ${path}`);
  return await res.json();
}

async function loadFiles() {
  try {
    const baseUrl = "https://raw.githubusercontent.com/reggie252/FischCalc/main/";
    Areas = await fetchJson(baseUrl + "fish_data.json");
    FishStats = await fetchJson(baseUrl + "fish_master_table.json");
    Rods = await fetchJson(baseUrl + "rod_master_table.json");
    Enchantments = await fetchJson(baseUrl + "enchantments.json");
    BaitData = await fetchJson(baseUrl + "bait_table.json");

    for (const mainArea in Areas) {
      for (const subLoc in Areas[mainArea]) {
        if (!Areas[mainArea][subLoc].includes("Enchant Relic")) Areas[mainArea][subLoc].push("Enchant Relic");
        if (!Areas[mainArea][subLoc].includes("Exalted Relic")) Areas[mainArea][subLoc].push("Exalted Relic");
      }
    }

    populateSelectors();
    populateEnchantments();
    populateBaits();
    updateStatsDisplay();
    document.getElementById("simControls").style.display = "block";
  } catch (err) {
    console.error(err);
    alert("Error loading files: " + err);
  }
}

window.onload = loadFiles;

function populateSelectors() {
  const mainAreaSelect = document.getElementById("mainAreaSelect");
  const subLocationSelect = document.getElementById("subLocationSelect");
  const rodSelect = document.getElementById("rodSelect");
  mainAreaSelect.innerHTML = "";
  subLocationSelect.innerHTML = "";
  rodSelect.innerHTML = "";

  Object.keys(Areas).sort().forEach(main => {
    const subLocations = Object.keys(Areas[main] || {});
    if (subLocations.length > 0) {
      const opt = document.createElement("option");
      opt.value = main;
      opt.textContent = main;
      mainAreaSelect.appendChild(opt);
    }
  });

  Object.keys(Rods).forEach(rod => {
    const opt = document.createElement("option");
    opt.value = rod;
    opt.textContent = rod;
    rodSelect.appendChild(opt);
  });

  populateSubLocations();
}

function populateSubLocations() {
  const mainAreaSelect = document.getElementById("mainAreaSelect");
  const subLocationSelect = document.getElementById("subLocationSelect");
  const selectedMain = mainAreaSelect.value;
  subLocationSelect.innerHTML = "";
  if (!Areas[selectedMain]) return;
  Object.keys(Areas[selectedMain]).forEach(subLoc => {
    const opt = document.createElement("option");
    opt.value = subLoc;
    opt.textContent = subLoc;
    subLocationSelect.appendChild(opt);
  });
}

function populateEnchantments() {
  const enchantSelect = document.getElementById("enchantSelect");
  enchantSelect.innerHTML = "";
  Object.keys(Enchantments).forEach(name => {
    const opt = document.createElement("option");
    opt.value = name;
    opt.textContent = name;
    enchantSelect.appendChild(opt);
  });
  enchantSelect.value = Object.keys(Enchantments)[0] || "";
}

function populateBaits() {
  const baitSelect = document.getElementById("baitSelect");
  baitSelect.innerHTML = "";
  let allBaits = [];
  Object.values(BaitData).forEach(category => allBaits.push(...Object.keys(category)));
  allBaits.forEach(b => {
    const opt = document.createElement("option");
    opt.value = b;
    opt.textContent = b;
    baitSelect.appendChild(opt);
  });
  if (allBaits.length > 0) baitSelect.value = allBaits[0];
  updateBaitStatsDisplay();
}

function updateBaitStatsDisplay() {
  const BaitCurrent = document.getElementById("baitSelect").value;
  const allBaits = Object.values(BaitData).reduce((acc, cat) => ({...acc, ...cat}), {});
  const selectedBaitStats = allBaits[BaitCurrent] || [0,0,0,0];
  document.getElementById("baitStats").textContent = 
    `Bait Stats â€” Preferred Luck: ${selectedBaitStats[0] ?? 0} | Universal Luck: ${selectedBaitStats[1] ?? 0}`;
}

function onMainAreaChange() {
  populateSubLocations();
  populateBaits();
}

function updateStatsDisplay() {
  const rod = document.getElementById("rodSelect").value;
  const enchant = document.getElementById("enchantSelect").value;
  const base = Rods[rod] || [0,0,0,0,0,0];
  const enchantStats = Enchantments[enchant] || [0,0,0,0,0,0];
  SelectedEnchantStats = enchantStats;
  const combined = base.map((v,i) => i===2 ? v : Math.round((v||0)+(enchantStats[i]||0)));
  const labels = ["Lure","Luck","Control","Resilience","Max KG","Progress Speed"];
  document.getElementById("rodStats").textContent = "Rod Stats: " + labels.map((l,i)=>`${l}: ${combined[i]}`).join(" | ");
}

// ---------- Helpers ----------
function randomChoiceWeighted(keys, weights) {
  const total = weights.reduce((a,b)=>a+b,0);
  if (total<=0) return keys[Math.floor(Math.random()*keys.length)];
  let r=Math.random()*total;
  for(let i=0;i<keys.length;i++){if((r-=weights[i])<=0) return keys[i];}
  return keys[keys.length-1];
}

function progressFormula(params, ProgressRod) {
  const fish = Number(params[0] ?? 0);
  const test_speed = Number(params[11] ?? 0);
  const p = (test_speed===1) ? Math.trunc(fish) : Math.trunc((ProgressRod??0)+fish);
  return 1.2 + 6.8/(1+p/100);
}

function matchesCondition(current, fishValue) {
  if (!fishValue || fishValue === "None") return true;
  const options = fishValue.split(",").map(s => s.trim());
  return options.includes(current);
}

function Chance(BaseChanceFish, RarityFish, HardPenalty, TimeFish, SeasonFish, BaitFish, WeatherFish, Yes, LuckRod, Rod, TimeCurrent, SeasonCurrent, WeatherCurrent) {
  // simplified for clarity
  return BaseChanceFish;
}

// ---------- Simulation ----------
function runSimulation() {
  const main = document.getElementById("mainAreaSelect").value;
  const sub = document.getElementById("subLocationSelect").value;
  if(!Areas[main]||!Areas[main][sub]){alert("Invalid area");return;}
  const fishList=Areas[main][sub];
  const rod=document.getElementById("rodSelect").value;
  const hours=parseFloat(document.getElementById("hoursInput").value)||0;
  const SeasonCurrent=document.getElementById("seasonSelect").value;
  const TimeCurrent=document.getElementById("timeSelect").value;
  const WeatherCurrent=document.getElementById("weatherSelect").value;
  const baseStats=Rods[rod]||[];
  const LuckRod=(baseStats[1]||0)+(SelectedEnchantStats[1]||0);
  const ProgressRod=(baseStats[5]||0)+(SelectedEnchantStats[5]||0);

  const Choices={};
  fishList.forEach(fish => { if(FishStats[fish]) Choices[fish] = [...FishStats[fish]]; if(Choices[fish]) Choices[fish][4]=0; });
  const fishKeys=Object.keys(Choices);
  if(fishKeys.length===0){alert("No fish in this selection");return;}

  let CurrentTime=0, EndTime=3600*hours, lastDynWeights=[];

  function pickAnEvent() {
    const currentArea = main;
    let dynWeights = fishKeys.map(name => {
      const c = Choices[name];
      const fishBaseWeight = c[12] || 0;
      const rodMaxKG = (baseStats[4] || 0) + (SelectedEnchantStats[4] || 0);

      if (name==="Enchant Relic" && currentArea!=="The Depths") return 0;
      if (rodMaxKG < fishBaseWeight) return 0;

      return Chance(c[3], c[5], c[6], c[7], c[8], c[9], c[10], c[11], LuckRod, rod, TimeCurrent, SeasonCurrent, WeatherCurrent);
    });

    const relicPercentages = {};
    if(currentArea!=="The Depths") relicPercentages["Enchant Relic"]=0.28;
    relicPercentages["Exalted Relic"]=0.05;
    fishKeys.forEach((name,i) => { if(relicPercentages[name]!==undefined) dynWeights[i]=relicPercentages[name]; });

    const sel = randomChoiceWeighted(fishKeys,dynWeights);
    Choices[sel][4]=(Choices[sel][4]||0)+1;

    lastDynWeights = dynWeights;
    return progressFormula(Choices[sel],ProgressRod);
  }

  while(CurrentTime<=EndTime){
    const nextDelta=pickAnEvent();
    CurrentTime+=nextDelta;
    if(!isFinite(CurrentTime)||nextDelta<=0) break;
  }

  const picks=fishKeys.map(name=>Choices[name][4]||0);

  const weightPercents = fishKeys.map((name,i)=>{
    const totalWeights=lastDynWeights.reduce((a,b)=>a+b,0);
    return totalWeights ? (100*lastDynWeights[i]/totalWeights) : 0;
  });

  function formatChance(chance) {
    if(chance===0) return "0%";
    let str=chance.toString();
    if(!str.includes(".")) return str+"%";
    let [intPart, decPart]=str.split(".");
    let cutoff=3 + (decPart.match(/^0*/)[0].length);
    return intPart+"."+decPart.slice(0,cutoff)+"%";
  }

  let html=`<table><thead><tr>
    <th>Name</th><th>Weather</th><th>Time</th><th>Season</th><th>Bait</th>
    <th>C$</th><th>XP</th><th>KG</th><th>Chance %</th><th>Progress Speed</th><th>Count</th>
  </tr></thead><tbody>`;

  fishKeys.forEach((name,i)=>{
    const c=Choices[name];
    const progSpeed=progressFormula(c,ProgressRod).toFixed(2);
    const fishBaseWeight=c[12]||0;
    const rodMaxKG=(baseStats[4]||0)+(SelectedEnchantStats[4]||0);
    const uncatchable = rodMaxKG<fishBaseWeight;

    html+=`<tr${uncatchable?' class="uncatchable"':''}>
      <td>${name}</td>
      <td>${c[10]}</td>
      <td>${c[7]}</td>
      <td>${c[8]}</td>
      <td>${c[9]}</td>
      <td>${c[1]}</td>
      <td>${c[2]}</td>
      <td>${fishBaseWeight}</td>
      <td>${formatChance(weightPercents[i])}</td>
      <td>${progSpeed}</td>
      <td>${picks[i]}</td>
    </tr>`;
  });

  html+="</tbody></table>";
  document.getElementById("results").innerHTML=html;
}
</script>
</body>
</html>
