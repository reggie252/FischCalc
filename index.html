<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Fishing Simulator</title>
<style>
  body { font-family: sans-serif; margin: 2rem; background: #f9fafb; color: #111; }
  h1 { font-size: 1.8rem; margin-bottom: 1rem; }
  select, input, button { padding: 0.5rem; margin: 0.2rem; }
  table { border-collapse: collapse; width: 100%; margin-top: 1rem; }
  th, td { border: 1px solid #ccc; padding: 0.5rem; text-align: left; }
  th { background: #eee; }
  .card { background: white; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
</style>
</head>
<body>
<h1>ðŸŽ£ Fishing Simulator</h1>

<div class="card">
  <p><b>Step 1:</b> Load your JSON files:</p>
  <label>fish_data.json: <input type="file" id="fishDataInput" accept=".json"/></label><br/>
  <label>fish_master_table.json: <input type="file" id="fishMasterInput" accept=".json"/></label><br/>
  <label>rod_master_table.json: <input type="file" id="rodMasterInput" accept=".json"/></label><br/>
  <label>enchantments.json: <input type="file" id="enchantmentsInput" accept=".json"/></label><br/>
  <label>bait.table.json: <input type="file" id="baitInput" accept=".json"/></label><br/>
  <button onclick="loadFiles()">Load Files</button>
</div>

<div class="card" id="simControls" style="display:none;">
  <label>Main Area:</label>
  <select id="mainAreaSelect" onchange="onMainAreaChange()"></select>

  <label>Sub-Location:</label>
  <select id="subLocationSelect"></select>

  <label>Rod:</label>
  <select id="rodSelect" onchange="updateStatsDisplay()"></select>

  <label>Enchantment:</label>
  <select id="enchantSelect" onchange="updateStatsDisplay()"></select>

  <label>Bait:</label>
  <select id="baitSelect" onchange="updateBaitStatsDisplay()"></select>
  <div id="baitStats" style="margin:0.5rem 0; font-weight:bold;">Bait Stats: -</div>

  <div id="rodStats" style="margin:0.5rem 0; font-weight:bold;">Rod Stats: -</div>

  <label>Hours:</label>
  <input type="number" id="hoursInput" value="1" step="0.5" min="0" />

  <label>Season:</label>
  <select id="seasonSelect">
    <option value="Spring">Spring</option>
    <option value="Summer">Summer</option>
    <option value="Autumn">Autumn</option>
    <option value="Winter" selected>Winter</option>
  </select>

  <label>Time:</label>
  <select id="timeSelect">
    <option value="Day" selected>Day</option>
    <option value="Night">Night</option>
  </select>

  <label>Weather:</label>
  <select id="weatherSelect">
    <option value="Clear" selected>Clear</option>
    <option value="Aurora Borealis">Aurora Borealis</option>
    <option value="Rain">Rain</option>
    <option value="Windy">Windy</option>
    <option value="Foggy">Foggy</option>
    <option value="Eclipse">Eclipse</option>
  </select>

  <button onclick="runSimulation()">Run Simulation</button>
</div>

<div class="card">
  <h2>Results</h2>
  <div id="results">No simulation yet.</div>
</div>

<script>
let Areas = {};
let FishStats = {};
let Rods = {};
let Enchantments = {};
let BaitData = {};
let SelectedEnchantStats = [0,0,0,0,0,0];

// ---------- Load JSON files ----------
function readJsonFile(inputElement) {
  return new Promise((resolve, reject) => {
    const file = inputElement.files[0];
    if (!file) { reject("No file chosen"); return; }
    const reader = new FileReader();
    reader.onload = e => {
      try { resolve(JSON.parse(e.target.result)); } 
      catch { reject("Invalid JSON in " + file.name); }
    };
    reader.onerror = () => reject("Error reading " + file.name);
    reader.readAsText(file);
  });
}

async function loadFiles() {
  try {
    Areas = await readJsonFile(document.getElementById("fishDataInput"));
    FishStats = await readJsonFile(document.getElementById("fishMasterInput"));
    Rods = await readJsonFile(document.getElementById("rodMasterInput"));
    Enchantments = await readJsonFile(document.getElementById("enchantmentsInput"));
    BaitData = await readJsonFile(document.getElementById("baitInput"));
    if (typeof BaitData !== 'object') BaitData = {};

    // --- Add "Enchant Relic" and "Exalted Relic" to each sub-location ---
    for (const mainArea in Areas) {
      for (const subLoc in Areas[mainArea]) {
        if (!Areas[mainArea][subLoc].includes("Enchant Relic")) {
          Areas[mainArea][subLoc].push("Enchant Relic");
        }
        if (!Areas[mainArea][subLoc].includes("Exalted Relic")) {
          Areas[mainArea][subLoc].push("Exalted Relic");
        }
      }
    }


    populateSelectors();
    populateEnchantments();
    populateBaits();
    updateStatsDisplay();
    document.getElementById("simControls").style.display = "block";
    alert("âœ… All files loaded!");
  } catch (err) {
    console.error(err);
    alert("Error loading files: " + err);
  }
}

// ---------- Populate dropdowns ----------
function populateSelectors() {
  const mainAreaSelect = document.getElementById("mainAreaSelect");
  const subLocationSelect = document.getElementById("subLocationSelect");
  const rodSelect = document.getElementById("rodSelect");

  mainAreaSelect.innerHTML = "";
  subLocationSelect.innerHTML = "";
  rodSelect.innerHTML = "";

  Object.keys(Areas).sort().forEach(main => {
    const subLocations = Object.keys(Areas[main] || {});
    if (subLocations.length > 0) {
      const opt = document.createElement("option");
      opt.value = main;
      opt.textContent = main;
      mainAreaSelect.appendChild(opt);
    }
  });

  Object.keys(Rods).forEach(rod => {
    const opt = document.createElement("option");
    opt.value = rod;
    opt.textContent = rod;
    rodSelect.appendChild(opt);
  });

  populateSubLocations();
}

// ---------- Populate sub-locations ----------
function populateSubLocations() {
  const mainAreaSelect = document.getElementById("mainAreaSelect");
  const subLocationSelect = document.getElementById("subLocationSelect");
  const selectedMain = mainAreaSelect.value;

  subLocationSelect.innerHTML = "";
  if (!Areas[selectedMain]) return;

  Object.keys(Areas[selectedMain]).forEach(subLoc => {
    const opt = document.createElement("option");
    opt.value = subLoc;
    opt.textContent = subLoc;
    subLocationSelect.appendChild(opt);
  });
}

// ---------- Populate Enchantments ----------
function populateEnchantments() {
  const enchantSelect = document.getElementById("enchantSelect");
  enchantSelect.innerHTML = "";
  Object.keys(Enchantments).forEach(name => {
    const opt = document.createElement("option");
    opt.value = name;
    opt.textContent = name;
    enchantSelect.appendChild(opt);
  });
  enchantSelect.value = Object.keys(Enchantments)[0] || "";
}

// ---------- Populate Baits ----------
function populateBaits() {
  const baitSelect = document.getElementById("baitSelect");
  baitSelect.innerHTML = "";

  // Flatten all baits from categories
  let allBaits = [];
  Object.values(BaitData).forEach(category => {
    allBaits.push(...Object.keys(category));
  });

  allBaits.forEach(b => {
    const opt = document.createElement("option");
    opt.value = b;
    opt.textContent = b;
    baitSelect.appendChild(opt);
  });

  if (allBaits.length > 0) baitSelect.value = allBaits[0];

  updateBaitStatsDisplay();
}

// ---------- Update bait stats display ----------
function updateBaitStatsDisplay() {
  const BaitCurrent = document.getElementById("baitSelect").value;

  const allBaits = Object.values(BaitData).reduce((acc, cat) => ({...acc, ...cat}), {});
  const selectedBaitStats = allBaits[BaitCurrent] || [0,0,0,0];
  const PreferredLuck = selectedBaitStats[0] ?? 0;
  const UniversalLuck = selectedBaitStats[1] ?? 0;

  document.getElementById("baitStats").textContent = 
    `Bait Stats â€” Preferred Luck: ${PreferredLuck} | Universal Luck: ${UniversalLuck}`;
}

// ---------- Called when main area changes ----------
function onMainAreaChange() {
  populateSubLocations();
  populateBaits();
}

// ---------- Update rod stats display ----------
function updateStatsDisplay() {
  const rod = document.getElementById("rodSelect").value;
  const enchant = document.getElementById("enchantSelect").value;
  const base = Rods[rod] || [0,0,0,0,0,0];
  const enchantStats = Enchantments[enchant] || [0,0,0,0,0,0];
  SelectedEnchantStats = enchantStats;

  const combined = base.map((v,i) => i===2 ? v : Math.round((v||0)+(enchantStats[i]||0)));
  const labels = ["Lure","Luck","Control","Resilience","Max KG","Progress Speed"];
  document.getElementById("rodStats").textContent = "Rod Stats: " + labels.map((l,i)=>`${l}: ${combined[i]}`).join(" | ");
}

// ---------- Simulation helpers ----------
function randomChoiceWeighted(keys, weights) {
  const total = weights.reduce((a,b)=>a+b,0);
  if (total<=0) return keys[Math.floor(Math.random()*keys.length)];
  let r=Math.random()*total;
  for(let i=0;i<keys.length;i++){if((r-=weights[i])<=0) return keys[i];}
  return keys[keys.length-1];
}
function progressFormula(params, ProgressRod) {
  const fish = Number(params[0] ?? 0);
  const test_speed = Number(params[11] ?? 0);
  const p = (test_speed===1) ? Math.trunc(fish) : Math.trunc((ProgressRod??0)+fish);
  return 1.2 + 6.8/(1+p/100);
}
function matchesCondition(current, fishValue) {
  if (!fishValue || fishValue === "None") return true; // means no restriction
  const options = fishValue.split(",").map(s => s.trim()); // ["Spring","Autumn"]
  return options.includes(current);
}


// ---------- Chance function using bait stats ----------
function Chance(BaseChanceFish, RarityFish, HardPenalty, TimeFish, SeasonFish, BaitFish, WeatherFish, Yes, LuckRod, Rod, TimeCurrent, SeasonCurrent, WeatherCurrent) {
  const BaitCurrent = document.getElementById("baitSelect").value;

  // Flatten bait JSON
  const allBaits = Object.values(BaitData).reduce((acc, cat) => ({...acc, ...cat}), {});
  const selectedBaitStats = allBaits[BaitCurrent] || [0,0,0,0];
  const PreferredLuck = selectedBaitStats[0] ?? 0;
  const UniversalLuck = selectedBaitStats[1] ?? 0;

  let LuckSever=0, LuckEnchantment=0, LuckStacks=0, ChanceAbundance=0;
  const EventCurrent="None", FishAbundance=null, TypeFish="1Crate", LocationCurrent="Ocean";

  const LuckConditions = (WeatherCurrent==="Aurora Borealis")?7:1;
  const BaitBoost = (Rod==="Resourceful Rod")?2:1;
  const LuckBait = (BaitCurrent===BaitFish)?PreferredLuck*BaitBoost:UniversalLuck*BaitBoost;

  let Luck=(LuckRod??0)+LuckBait+LuckEnchantment+(5*LuckStacks);
  if(Luck<0){
    const ratio=(-Luck)/(BaseChanceFish);
    Luck=(LuckConditions+LuckSever)*(-Math.log(ratio));
  }else{
    const ratio=Luck/(BaseChanceFish);
    Luck=(LuckConditions+LuckSever)*(Math.log(ratio));
  }
  if(Luck<0) Luck=0;

  const rarityIsHigh=(typeof RarityFish==="number")?(RarityFish>=5):false;
  const rarityIsLow=(typeof RarityFish==="number")?(RarityFish<=1):false;
  const baseLow=(BaseChanceFish<=40);
  const LuckFactor=(rarityIsHigh||(!rarityIsLow&&baseLow))?Luck:-20*Luck;
  const MagnetFactor=(Rod==="Magnet Rod" && TypeFish==="Crate")?10000:0;
  const Cap=200+ChanceAbundance+MagnetFactor;
  const TimeMultiplier = (matchesCondition(TimeCurrent, TimeFish) || Rod === "Nocturnal Rod")?1:0.1;
  const WeatherFactor = matchesCondition(WeatherCurrent, WeatherFish) ?(BaseChanceFish * 0.35):0;
  const SeasonFactor = matchesCondition(SeasonCurrent, SeasonFish)?(BaseChanceFish*0.25):(BaseChanceFish*-0.15);
  const SeasonMultiplier = (matchesCondition(SeasonCurrent, SeasonFish) && Rod === "Seasons Rod") ? 1.2:1;
  const AbundanceMultiplier=(FishAbundance==="Fish"&&!ChanceAbundance)?1.7:1;
  const AncientIsleMultiplier=(typeof RarityFish==="number"&&RarityFish===5 && LocationCurrent==="Ancient Isle")?0.5:1;
  const LowRarityPenalty=(typeof RarityFish==="number"&&RarityFish<=2 && Luck>=200)?10:1;

  const AdjustedChance=((((BaseChanceFish+SeasonFactor)*SeasonMultiplier+WeatherFactor+ChanceAbundance)*AbundanceMultiplier+MagnetFactor)*TimeMultiplier);
  let Chance1=(((AdjustedChance+LuckFactor)/((HardPenalty)*LowRarityPenalty))*AncientIsleMultiplier);
  Chance1=(Chance1<0)?0:(Chance1>=Cap?Cap:Chance1);
  return Chance1;
}

// ---------- Run simulation ----------
function runSimulation() {
  const main=document.getElementById("mainAreaSelect").value;
  const sub=document.getElementById("subLocationSelect").value;
  if(!Areas[main]||!Areas[main][sub]){alert("Invalid area");return;}

  const fishList=Areas[main][sub];
  const rod=document.getElementById("rodSelect").value;
  const hours=parseFloat(document.getElementById("hoursInput").value)||0;
  const SeasonCurrent=document.getElementById("seasonSelect").value;
  const TimeCurrent=document.getElementById("timeSelect").value;
  const WeatherCurrent=document.getElementById("weatherSelect").value;

  if(!Rods[rod]){alert("Invalid rod");return;}

  const baseStats=Rods[rod]||[];
  const LuckRod=(baseStats[1]||0)+(SelectedEnchantStats[1]||0);
  const ProgressRod=(baseStats[5]||0)+(SelectedEnchantStats[5]||0);

  const Choices={};
  fishList.forEach(fish=>{if(FishStats[fish]) Choices[fish]=[...FishStats[fish]]; if(Choices[fish]) Choices[fish][4]=0;});

  const fishKeys=Object.keys(Choices);
  if(fishKeys.length===0){alert("No fish in this selection");return;}

  let CurrentTime=0;
  const EndTime=3600*hours;
  let lastDynWeights=[];

  function pickAnEvent() {
    const currentArea = main; // selected main area

    // Calculate normal weights for all fish
    let dynWeights = fishKeys.map(name => {
      const c = Choices[name];

      if (name === "Enchant Relic" && currentArea !== "The Depths") return 0; // forced later
      if (name === "Exalted Relic") return 0; // forced later

      // For The Depths, Enchant Relic uses normal Chance
      return Chance(c[3], c[5], c[6], c[7], c[8], c[9], c[10], c[11], LuckRod, rod, TimeCurrent, SeasonCurrent, WeatherCurrent);
    });

    // Sum of normal fish weights
    const normalTotal = dynWeights.reduce((a,b)=>a+b,0);

    // Forced relic percentages (only where applicable)
    const relicPercentages = {};
    if (currentArea !== "The Depths") relicPercentages["Enchant Relic"] = 0.28;
    relicPercentages["Exalted Relic"] = 0.05;

    // Scale normal fish weights to sum to remaining probability
    const remainingPercent = 100 - Object.values(relicPercentages).reduce((a,b)=>a+b,0);
    const scale = normalTotal / remainingPercent;
    dynWeights = dynWeights.map(w => w / scale);

    // Add forced relic weights
    fishKeys.forEach((name,i) => {
      if (relicPercentages[name] !== undefined) dynWeights[i] = relicPercentages[name];
    });

    const sel = randomChoiceWeighted(fishKeys, dynWeights);
    Choices[sel][4] = (Choices[sel][4] || 0) + 1;

    const T1 = progressFormula(Choices[sel], ProgressRod);
    lastDynWeights = dynWeights;
    return T1;
  }

  while(CurrentTime<=EndTime){
    const nextDelta=pickAnEvent();
    CurrentTime+=nextDelta;
    if(!isFinite(CurrentTime)||nextDelta<=0) break;
  }

  const picks=fishKeys.map(name=>Choices[name][4]||0);
  const totalWeights=lastDynWeights.reduce((a,b)=>a+b,0);
  const weightPercents=lastDynWeights.map(w=>totalWeights?(100*w/totalWeights):0);

  let totalXP=0, totalMoney=0;
  fishKeys.forEach(name=>{
    const c=Choices[name];
    const count=c[4]||0;
    totalXP+=(c[2]||0)*count;
    totalMoney+=(c[1]||0)*count;
  });

  let html=`<table>
    <thead>
      <tr>
        <th>Name</th><th>Weather</th><th>Time</th><th>Season</th><th>Bait</th>
        <th>C$</th><th>XP</th><th>Chance %</th><th>Progress Speed</th><th>Count</th>
      </tr>
    </thead>
    <tbody>`;

  fishKeys.forEach((name,i)=>{
    const c=Choices[name];
    const progSpeed=progressFormula(c,ProgressRod).toFixed(2);
    html+=`<tr>
      <td>${name}</td>
      <td>${c[10]}</td>
      <td>${c[7]}</td>
      <td>${c[8]}</td>
      <td>${c[9]}</td>
      <td>${c[1]}</td>
      <td>${c[2]}</td>
      <td>${weightPercents[i].toFixed(2)}%</td>
      <td>${c[0]}</td>
      <td>${picks[i]}</td>
    </tr>`;
  });

  html+=`</tbody></table>
    <p><b>Total XP Gained:</b> ${totalXP}</p>
    <p><b>Total Money Earned:</b> C$${totalMoney.toFixed(2)}</p>`;

  document.getElementById("results").innerHTML=html;
}
</script>
</body>
</html>
